[
["index.html", "R for Research Preface", " R for Research Abhay Singh 2020-07-27 Preface This is a part-I of the compilation of handouts for \\(R^2: R for Research\\) on getting started with R. This part will cover the following Getting Started R Data Types &amp; Data Structures A Short Introduction to R Programming Data Exploration: Preprocessing, Transformation Graphics in R "],
["1-what-is-r.html", "Chapter 1 What is R?", " Chapter 1 What is R? `` According to the official webpage: R is a language and environment for statistical computing and graphics. It is a GNU project which is similar to the S language and environment which was developed at Bell Laboratories (formerly AT&amp;T, now Lucent Technologies) by John Chambers and colleagues. R can be considered as a different implementation of S. There are some important differences, but much code written for S runs unaltered under R. http://www.r-project.org/about.html According to Wikipedia R is a free software programming language and a software environment for statistical computing and graphics. The R language is widely used among statisticians and data miners for developing statistical software and data analysis. Polls and surveys of data miners are showing R’s popularity has increased substantially in recent years. To Summarise R is the most amazing free statistical software ever! This recent video by Revolution Analytics does a great job in summarizing R ! "],
["1-1-why-should-we-learn-r.html", "1.1 Why should we learn R?", " 1.1 Why should we learn R? R follows a type inference1 coding structure and provides a wide variety of statistical and graphical techniques, including; Linear and non-linear modelling Univariate &amp; Multivariate Statistics Classical statistical tests Time-series analysis/ Econometrics Simulation and Modelling Datamining-classification, clustering etc. For computationally intensive tasks, C, C++, and Fortran code can be linked and called at run time. R is easily extensible through functions and extensions, and the R community is noted for its active contributions in terms of packages. # Number of R Packages length(available.packages(repos = &quot;http://cran.us.r-project.org&quot;)[, 1]) [1] 16024 Total 16024 packages and counting Type inference refers to the automatic deduction of the type of an expression in a programming language.↩︎ "],
["1-2-Rinstall.html", "1.2 Installing R and RStudio on Windows", " 1.2 Installing R and RStudio on Windows The latest version of R can be download from the R homepage. R download page: http://www.cran.r-project.org/bin/windows/base/ The page also provides some instructions and FAQ’s on R installation. RStudio IDE ( IDE: Integrated Development Environment) is a powerful and productive user interface for R. It’s free and open source, and works great on Windows, Mac, and Linux "],
["1-3-rstudio-guiide.html", "1.3 RStudio GUI/IDE", " 1.3 RStudio GUI/IDE RStudio GUI is composed of 4 panes which can be rearranged according to the requirements. There are a lot of short introductions to RStudio available online so we will not go into more details. Download Rstudio from here https://rstudio.com/products/rstudio/download/#download The figure below gives the snapshot of RStudio GUI. Figure 1.1: RStudio IDE A short intro to RStudio ! RStudio Overview - 1:30 from RStudio, Inc. on Vimeo. "],
["1-4-installing-packages.html", "1.4 Installing Packages", " 1.4 Installing Packages The easiest way to install packages is to do it via R console. The command install.packages(“package name”) installs R packages directly from internet. Other options to install various dependencies to a package can be easily specified when calling this function. A call to this function asks the user to chose a CRAN mirror at the first instance. Run the following to install Quantreg package on R. Also use the help function to get the details. # Install a package using RStudio Console install.packages(&quot;quantreg&quot;, dependencies = c(&quot;Depends&quot;, &quot;Suggests&quot;)) install.packages(c(&quot;zoo&quot;, &quot;reshape2&quot;, &quot;quantreg&quot;, &quot;e1071&quot;, &quot;foreign&quot;, &quot;psych&quot;, &quot;pastecs&quot;, &quot;ggplot2&quot;, &quot;stargazer&quot;, &quot;formatR&quot;, &quot;plm&quot;, &quot;xts&quot;, &quot;tseries&quot;, &quot;fArma&quot;), dependencies = TRUE) # to be updated "],
["1-5-getting-help.html", "1.5 Getting Help", " 1.5 Getting Help As R is constantly evolving and new functions/packages are introduced every day it is good to know sources of help. The most basic help one can get is via the help() function. This function shows the help file for a function which has been created by package managers. help(&quot;function name&quot;) The following can be used to search for a function etc. #Replace the &#39;search string&#39; with the expression you want to search ??search string All the R packages (with few exceptions) have a user’s manual listing the functions in a package. This can be downloaded in PDF format from the R package download page2. R also provides some search tools given at http://cran.r-project.org/search.html The R Site search is helpful in searching for topics related to problem in hand. Other than these various good R related blogs are on the internet which can be really helpful. A combined upto date view of 452 contributed blogs can be found at R-bloggers3. Over all there quite a big community of R Users and help can be found for most of the topics. For example reference manual for quantreg package is at http://cran.r-project.org/web/packages/quantreg/quantreg.pdf↩︎ Go to [www.r-bloggers.com]: www.r-bloggers.com↩︎ "],
["1-6-task-views-in-r-introduction-installation.html", "1.6 Task Views in R-Introduction &amp; Installation", " 1.6 Task Views in R-Introduction &amp; Installation Task Views in R provide packages grouped together according to a generalized task they are used for. Table below gives the name of task views available4. The following commands install the package ctv and then Finance task view. # install package task views install.packages(&quot;ctv&quot;) library(&quot;ctv&quot;) #R function library() is used to call a package # install Finance task view install.views(&quot;Finance&quot;) Figure 1.2: Task Views This list of available task views can be found at http://cran.r-project.org/web/views/↩︎ "],
["1-7-r-core-packages.html", "1.7 R core packages", " 1.7 R core packages R comes with few bundled core packages which provide various data analytics/statistical capabilities to R. The base package in R has basic functions and operators which are required for analytical programming, stats is another example of core R packages. # List of R core packages row.names(installed.packages(priority = &quot;base&quot;)) [1] &quot;base&quot; &quot;compiler&quot; &quot;datasets&quot; &quot;graphics&quot; &quot;grDevices&quot; &quot;grid&quot; [7] &quot;methods&quot; &quot;parallel&quot; &quot;splines&quot; &quot;stats&quot; &quot;stats4&quot; &quot;tcltk&quot; [13] &quot;tools&quot; &quot;utils&quot; "],
["1-8-example-1-hello-r.html", "1.8 Example-1 Hello R!", " 1.8 Example-1 Hello R! message(&quot;Hello R!&quot;) #use to display messages print(&quot;Hello R!&quot;) #use to display variables/messages [1] &quot;Hello R!&quot; msg = &quot;Hello R!&quot; #type inference no need to define strings! print(msg) [1] &quot;Hello R!&quot; R packages not just come with demo programs but the help files for the functions in R packages mostly have example codes for the particular function. R function example() is helpful in running the example code for a function. For running example code for in quantreg package type example(rq, package=”quantreg”) "],
["2-r-data-types-and-data-structures.html", "Chapter 2 R Data Types and Data Structures", " Chapter 2 R Data Types and Data Structures When human judgement and big data intersect there are some funny things that happen. -Nate Silver "],
["2-1-data-types.html", "2.1 Data Types", " 2.1 Data Types As per R’s official language definitions; in every computer language variables provide a means of accessing the data stored in memory. R does not provide direct access to the computer’s memory but rather provides a number of specialized data structures we will refer to as objects. These objects are referred to through symbols or variables. 2.1.1 Double Doubles are numbers like 5.0, 5.5, 10.999 etc. They may or may not include decimal places. Doubles are mostly used to represent a continuous variable like serial number, weight, age etc. x = 8.5 is.double(x) #to check if the data type is double [1] TRUE 2.1.2 Integer Integers are natural numbers. x = 9 typeof(x) [1] &quot;double&quot; # The following specifically assigns an integer to x x = as.integer(9) typeof(x) [1] &quot;integer&quot; 2.1.3 Logical A variable of data type logical has the value TRUE or FALSE. To perform calculation on logical objects in R the FALSE is replaced by a zero and TRUE is replaced by 1. x = 11 y = 10 a = x &gt; y a [1] TRUE typeof(a) [1] &quot;logical&quot; 2.1.4 Character Characters represent the string values in R. An object of type character can have alphanumeric strings. Character objects are specified by assigning a string or collection of characters between double quotes (“ string”) . Everything in a double quote is considered a string in R. 2.1.5 Factor -Factor is an important data type to represent categorical data. This also comes handy when dealing with Panel or Longitudinal data. Example of factors are Blood type (A , B, AB, O), Sex (Male or Female). Factor objects can be created from character object or from numeric object. -The operator c is used to create a vector of values which can be of any data type. b.type = c(&quot;A&quot;, &quot;AB&quot;, &quot;B&quot;, &quot;O&quot;) #character object # use factor function to convert to factor object b.type = factor(b.type) b.type [1] A AB B O Levels: A AB B O # to get individual elements (levels) in factor object levels(b.type) [1] &quot;A&quot; &quot;AB&quot; &quot;B&quot; &quot;O&quot; 2.1.6 Date &amp; Time -R is capable of dealing calendar dates and times. It is an important object when dealing with time series models. The function as.Date can be used to create an object of class Date. - see help(as.Date) for more details about the format of dates. date1 = &quot;31-01-2012&quot; date1 = as.Date(date1, &quot;%d-%m-%Y&quot;) date1 [1] &quot;2012-01-31&quot; data.class(date1) [1] &quot;Date&quot; # The date and time are internally interpreted as Double so the function typeof # will return the type Double typeof(date1) [1] &quot;double&quot; "],
["2-2-data-structures-in-r.html", "2.2 Data Structures in R", " 2.2 Data Structures in R Every data analysis requires the data to be structured in a well defined way. These coherent ways to put together data forms some basic data structures in R. Every data set intended for analysis has to be imported in R environment as a data structure. R has the following basic data structures: • Vector • Matrix • Array • Data Frame • Lists 2.2.1 Vector Vectors are group of values having same data types. There can be numeric vectors, character vector and so on. Vectors are mostly used to represent a single variable in a data set. A vector is constructed using the function c. The same function c can be used to combine different vectors of same data type. vec1 = c(1, 2, 3, 4, 5) vec1 [1] 1 2 3 4 5 The str function can be used to view the data structure of an object 2.2.2 Matrices A matrix is a collection of data elements arranged in a two-dimensional rectangular layout. Like vectors all the elements in a matrix are of same data type. \\[\\left[\\begin{array}{cc} 1 &amp; 2\\\\ 3 &amp; 4\\\\ 5 &amp; 6 \\end{array}\\right]\\] The function \\(\\mathtt{matrix}\\) is used to create matrices in R. Note that all the elements in a matrix object are of same basic type. Lets create the matrix in the example above. m1 = matrix(c(1, 2, 3, 4, 5, 6), nrow = 3, ncol = 2, byrow = TRUE) # nrow-specify number of rows, ncol-specify number of columns, byrow-fill the # matrix in rows with the data supplied m1 #print the matrix [,1] [,2] [1,] 1 2 [2,] 3 4 [3,] 5 6 A vector can be converted to matrix using \\(\\mathtt{dim}\\) function, e.g: m2 = c(1, 2, 3, 4, 5, 6) dim(m2) = c(3, 2) #the matrix will be filled by columns m2 [,1] [,2] [1,] 1 4 [2,] 2 5 [3,] 3 6 # use dim to get the dimension (#rows and #columns) of a matrix dim(m1) [1] 3 2 ** Matrix Manipulations ** For calculations on matrices; all the mathematical functions available for vectors are applicable on a matrix. All operations are applied on each element in a matrix, e.g. m3 = m1 * 2 # all elements will be multiplied by 2 individually m3 [,1] [,2] [1,] 2 4 [2,] 6 8 [3,] 10 12 A matrix can be multiplied with a vector as long as the length of the vector is a multiple of length of the matrix. Try different combinations of matrix and vector arithmetic to see the results and errors. Mathematical matrix operations are also available for matrices in R. For instance \\(\\mathtt{\\%*\\%}\\) is used for matrix multiplication, the matrices must agree dimensionally for matrix multiplication. Note the use of \\(\\mathtt{:}\\) operator to create a sequence. dim(m1) # 3 rows and 2 columns [1] 3 2 # create another matrix with 2 rows and 3 columns m3 = matrix(c(1:6), ncol = 3) m1 %*% m3 [,1] [,2] [,3] [1,] 5 11 17 [2,] 11 25 39 [3,] 17 39 61 R facilitates various matrix specific operations. Table 1 gives most of the available functions and operators. Use \\(\\mathtt{help()}\\) or \\(\\mathtt{?}\\) followed by function name to get more details about the operators and functions. Table : Functions and operators for matrices Operator or Function Description X * Y Element-wise multiplication X %*% Y Matrix multiplication Y %o% X Outer product. XB’ crossprod(X,Y) X’Y crossprod(X) X’X t(X) Transpose diag(x) Creates diagonal matrix with elements of x in the principal diagonal diag(X) Returns a vector containing the elements of the principal diagonal diag(k) If k is a scalar, this creates a k x k identity matrix. Go figure. solve(X, b) Returns vector x in the equation b = Xx (i.e., X-1b) solve(X) Inverse of X where X is a square matrix. y=eigen(X) y$val are the eigenvalues of X y$vec are the eigenvectors of X y=svd(X) Singular value decomposition of X. R = chol(X) Choleski factorization of X. Returns the upper triangular factor, such that R’R = X. y = qr(X) QR decomposition of X. cbind(X,Y,…) Combine matrices(vectors) horizontally. Returns a matrix. rbind(X,Y,…) Combine matrices(vectors) vertically. Returns a matrix. rowMeans(X) Returns vector of row means. rowSums(X) Returns vector of row sums. colMeans(X) Returns vector of column means. colSums(X) Returns vector of column means. 2.2.3 Arrays Arrays are the generalisation of vectors and matrices. A vector in R is a one dimensional array and a matrix a two dimensional array. An array is a multiply subscripted collection of data entries of the same data type. Arrays can be constructed using the function \\(\\mathtt{array}\\), for example5 z = c(1:24) #vector of length 24 # constructing a 3 by 4 by 2 array a1 = array(z, dim = c(3, 4, 2)) a1 , , 1 [,1] [,2] [,3] [,4] [1,] 1 4 7 10 [2,] 2 5 8 11 [3,] 3 6 9 12 , , 2 [,1] [,2] [,3] [,4] [1,] 13 16 19 22 [2,] 14 17 20 23 [3,] 15 18 21 24 Individual elements of an array are accessed by referring them by their index. This is done by giving the name of the array followed by the subscript (index) in this square bracket separated by commas. We try to access the element [1,3,1] of array a1 in the following example # element in the row 1 and column 3 in the first subset a1[1, 3, 1] [1] 7 2.2.4 Data Frames Data frame forms the most convenient data structures in R to represent tabular data. In quantitative research data is often in the form of data tables. These data tables have multiple rows and can have multiple columns with each column representing a different variable (quantity). A data frame in R is the most natural way to represent these data sets as it can have different data type in the data frame object. Most statistical routines in R require a data frame as input. The following example uses an important function \\(\\mathtt{str}\\) on R’s inbuilt data frame “swiss”. \\(\\mathtt{str}\\) function is used to see the internal structure of an object in R. options(str = list(vec.len = 2)) # swiss dataframe has standardized fertility measure and socio-economic # indicators for each of 47 French-speaking provinces of Switzerland at about # 1888. data(swiss) str(swiss) &#39;data.frame&#39;: 47 obs. of 6 variables: $ Fertility : num 80.2 83.1 92.5 85.8 76.9 ... $ Agriculture : num 17 45.1 39.7 36.5 43.5 ... $ Examination : int 15 6 5 12 17 ... $ Education : int 12 9 5 7 15 ... $ Catholic : num 9.96 84.84 ... $ Infant.Mortality: num 22.2 22.2 20.2 20.3 20.6 ... Data frames have two attributes namely; \\(\\mathtt{names}\\) and \\(\\mathtt{row.names}\\), these two contains the column names and row names respectively. The data in the named column can be accessed by the \\(\\mathtt{\\$}\\) operator. # using names and row.names names(swiss) #name of the columns (can also use colnames) [1] &quot;Fertility&quot; &quot;Agriculture&quot; &quot;Examination&quot; &quot;Education&quot; [5] &quot;Catholic&quot; &quot;Infant.Mortality&quot; colnames(swiss) [1] &quot;Fertility&quot; &quot;Agriculture&quot; &quot;Examination&quot; &quot;Education&quot; [5] &quot;Catholic&quot; &quot;Infant.Mortality&quot; row.names(swiss) #name of the rows [1] &quot;Courtelary&quot; &quot;Delemont&quot; &quot;Franches-Mnt&quot; &quot;Moutier&quot; &quot;Neuveville&quot; [6] &quot;Porrentruy&quot; &quot;Broye&quot; &quot;Glane&quot; &quot;Gruyere&quot; &quot;Sarine&quot; [11] &quot;Veveyse&quot; &quot;Aigle&quot; &quot;Aubonne&quot; &quot;Avenches&quot; &quot;Cossonay&quot; [16] &quot;Echallens&quot; &quot;Grandson&quot; &quot;Lausanne&quot; &quot;La Vallee&quot; &quot;Lavaux&quot; [21] &quot;Morges&quot; &quot;Moudon&quot; &quot;Nyone&quot; &quot;Orbe&quot; &quot;Oron&quot; [26] &quot;Payerne&quot; &quot;Paysd&#39;enhaut&quot; &quot;Rolle&quot; &quot;Vevey&quot; &quot;Yverdon&quot; [31] &quot;Conthey&quot; &quot;Entremont&quot; &quot;Herens&quot; &quot;Martigwy&quot; &quot;Monthey&quot; [36] &quot;St Maurice&quot; &quot;Sierre&quot; &quot;Sion&quot; &quot;Boudry&quot; &quot;La Chauxdfnd&quot; [41] &quot;Le Locle&quot; &quot;Neuchatel&quot; &quot;Val de Ruz&quot; &quot;ValdeTravers&quot; &quot;V. De Geneve&quot; [46] &quot;Rive Droite&quot; &quot;Rive Gauche&quot; swiss$Fertility #returns the vector of data in the column Fertility [1] 80.2 83.1 92.5 85.8 76.9 76.1 83.8 92.4 82.4 82.9 87.1 64.1 66.9 68.9 61.7 [16] 68.3 71.7 55.7 54.3 65.1 65.5 65.0 56.6 57.4 72.5 74.2 72.0 60.5 58.3 65.4 [31] 75.5 69.3 77.3 70.5 79.4 65.0 92.2 79.3 70.4 65.7 72.7 64.4 77.6 67.6 35.0 [46] 44.7 42.8 Data frames are constructed using the function \\(\\mathtt{data.frame}\\). For example following creates a data frame of a character and numeric vector. num1 = seq(1:5) ch1 = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;) df1 = data.frame(ch1, num1) df1 ch1 num1 1 A 1 2 B 2 3 C 3 4 D 4 5 E 5 2.2.5 Lists A list is like generic vector containing other objects. Lists can have numerous elements any type and structure they can also be of different lengths A list can contain another list and therefore it can be used to construct arbitrary data structures. A list can be constructed using the \\(\\mathtt{list}\\) function, for example e1 = c(2, 3, 5) #element-1 e2 = c(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;, &quot;ee&quot;) #element-2 e3 = c(TRUE, FALSE, TRUE, FALSE, FALSE) #element-3 e4 = df1 #element-4 (previously constructed data frame) lst1 = list(e1, e2, e3, e4) # lst contains copies of e1,e2,e3,e4 str(lst1) #show the structure of lst1 List of 4 $ : num [1:3] 2 3 5 $ : chr [1:5] &quot;aa&quot; &quot;bb&quot; ... $ : logi [1:5] TRUE FALSE TRUE ... $ :&#39;data.frame&#39;: 5 obs. of 2 variables: ..$ ch1 : chr [1:5] &quot;A&quot; &quot;B&quot; ... ..$ num1: int [1:5] 1 2 3 4 5 Components are always numbered and may always be referred to as such. Figure 2.1: Lists Thus if lst1 is the name of a list with four components, these may be individually referred to as lst1[[1]], lst1[[2]], lst1[[3]] and lst1[[4]]. Note: When a single square bracket is used the component of a list is returned as a list while the double square bracket returns the component itself # first element of lst1 lst1[[1]] [1] 2 3 5 lst1[1] [[1]] [1] 2 3 5 The elements in a list can also be named using the function and these elements can be referred individually via there names. names(lst1) = c(&quot;e1&quot;, &quot;e2&quot;, &quot;e3&quot;, &quot;e4&quot;) names(lst1) #name of the elements [1] &quot;e1&quot; &quot;e2&quot; &quot;e3&quot; &quot;e4&quot; lst1$e1 #using $operator to refer the element [1] 2 3 5 This section provided an overview of various data types and data structures in R. The next section will discuss how to deal with external data souces with flat data. Function \\(\\mathtt{dim}\\) can also be used to define an array by assigning dimensions to a vector.↩︎ "],
["2-3-data-importexport-in-r.html", "2.3 Data Import/Export in R", " 2.3 Data Import/Export in R 2.3.1 Reading Data from a Text File The easiest way to import data into R’s statistical system is to do in a tabular format saved in a text/ file. To import tabular data from a text file, R provides the function \\(\\mathtt{read.table()}\\). \\(\\mathtt{read.table()}\\) is the most convenient function to import tabular data from text files and can be easily used for data files of small or moderate size having data in a rectangular format. The arguments which can be passed to \\(\\mathtt{read.table()}\\) are given below. args(read.table) function (file, header = FALSE, sep = &quot;&quot;, quote = &quot;\\&quot;&#39;&quot;, dec = &quot;.&quot;, numerals = c(&quot;allow.loss&quot;, &quot;warn.loss&quot;, &quot;no.loss&quot;), row.names, col.names, as.is = !stringsAsFactors, na.strings = &quot;NA&quot;, colClasses = NA, nrows = -1, skip = 0, check.names = TRUE, fill = !blank.lines.skip, strip.white = FALSE, blank.lines.skip = TRUE, comment.char = &quot;#&quot;, allowEscapes = FALSE, flush = FALSE, stringsAsFactors = default.stringsAsFactors(), fileEncoding = &quot;&quot;, encoding = &quot;unknown&quot;, text, skipNul = FALSE) NULL Some of the important arguments for the function \\(\\mathtt{read.table}\\) are discussed below, for the rest see the help file using \\(\\mathtt{help(read.table)}\\). Argument Description file The name of the tabular (text) file to import along with the full path header A logical argument to specify if the names of the variables are available in the first row sep Character to specify the seperator type, default “ “ takes any white space as a separator quote To specify if the character vectors in the data are in quotes, this shuold specify the type of quotes as.is To specify if the character vectors should be converted to factors. The default behaviour is to read characters as characters and not factors strip.white A logical value to specify if the extra leading and trailing white spaces have to be removed from the character fiels. This is used when sep !=\". fill Logical value to specify if the blank fields in a row should be filled. The example below imports a tab delimited text file. Note the use of “ in the sep argument for tab delimited data . The header argument is also TRUE here as our dataset has variable names in the first row. Note that in the example below, the working directory for the RStudio session has already been set to the destination file’s directory (data folder). If the working directory is different from the location of the data file then either the working directory should be changed using \\(\\mathtt{setwd}\\) or RStudio’s GUI or full path for the file’s location should be provided with the file name. data_readtable = read.table(&quot;data/demo_data.txt&quot;, sep = &quot;\\t&quot;, header = TRUE) head(data_readtable) Date AAPL MSFT 1 2/01/1998 4.06 16.39 2 5/01/1998 3.97 16.30 3 6/01/1998 4.73 16.39 4 7/01/1998 4.38 16.20 5 8/01/1998 4.55 16.31 6 9/01/1998 4.55 15.88 This data can be now saved into .Rdata format after importing from a text file using \\(\\mathtt{save}\\) or can be written to another text file using \\(\\mathtt{write.table}\\) as shown below: # saving data as an object in .Rdata format save(data_readtable, file = &quot;data/data1.Rdata&quot;) # saving data into another text file write.table(data_readtable, file = &quot;data/data1.txt&quot;) Another convenient way to store the data is to store in RDS format. saveRDS(data_readtable, file = &quot;data/data1_rds.Rds&quot;) These data files can then be loaded using load and readRDS functions load(&quot;data/data1.Rdata&quot;) head(data_readtable) Date AAPL MSFT 1 2/01/1998 4.06 16.39 2 5/01/1998 3.97 16.30 3 6/01/1998 4.73 16.39 4 7/01/1998 4.38 16.20 5 8/01/1998 4.55 16.31 6 9/01/1998 4.55 15.88 Rds format can be loaded into a different object data_readtable2 = readRDS(&quot;data/data1_rds.Rds&quot;) str(data_readtable2) &#39;data.frame&#39;: 3936 obs. of 3 variables: $ Date: chr &quot;2/01/1998&quot; &quot;5/01/1998&quot; ... $ AAPL: num 4.06 3.97 4.73 4.38 4.55 ... $ MSFT: num 16.4 16.3 ... 2.3.2 Reading Data from CSV files Reading data from a CSV file is made easy by the \\(\\mathtt{read.csv}\\) function. \\(\\mathtt{read.csv}\\) function is an extension of \\(\\mathtt{read.table}\\). It facilitates direct import of data from CSV files. \\(\\mathtt{read.csv}\\) function takes the following arguments The following example imports a CSV file with the same data as previously imported from a text file. # Check the working directory before importing else provide full path data_readcsv = read.csv(&quot;data/demo_data.csv&quot;) head(data_readcsv) Date AAPL MSFT 1 2/01/1998 4.06 16.39 2 5/01/1998 3.97 16.30 3 6/01/1998 4.73 16.39 4 7/01/1998 4.38 16.20 5 8/01/1998 4.55 16.31 6 9/01/1998 4.55 15.88 Similar to \\(\\mathtt{write.table}\\) data can also be written to an external csv file using \\(\\mathtt{write.csv}\\). The following example uses an inbuilt data set in R and exports it to a CSV. Notice the use of row.names=FALSE to avoid creating one more column in the CSV file with row numbers data(iris) #R inbuilt dataset head(iris) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3.0 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa 4 4.6 3.1 1.5 0.2 setosa 5 5.0 3.6 1.4 0.2 setosa 6 5.4 3.9 1.7 0.4 setosa write.csv(iris, &quot;data/data_iris.csv&quot;, row.names = FALSE) 2.3.3 Reading from Excel Files R does provide methods to import data from excel file with the help of external packages. There are methods provided by packages like readxl, \\(\\mathtt{gdata}\\), \\(\\mathtt{XLConnet}\\), \\(\\mathtt{xlsx}\\). 2.3.4 Reading from Data Files from other Statistical Systems When migrating from software like SPSS, Stata, Matlab users might want to use there old datasets generated from these systems in R. This requires methods for importing these datasets into R. There are packages like \\(\\mathtt{haven}\\), \\(\\mathtt{foreign}\\) and \\(\\mathtt{R.matlab}\\) which provide these functionality. 2.3.5 Importing Data using RStudio To import data click on Import Dataset \\(\\rightarrow\\) From Excel.. \\(\\rightarrow\\) for the file to import. Remember the file should be in a tabular format, a text file or a csv are the best options. On clicking Import the data will be imported in a Data Frame and will be made visible by RStudio. This will also generate basic data import command used for importing and viewing the file in the RStudio console as shown in the figure below. Note that the path in the command as shown in the console has been scrambled as it will be different for every computer Figure 2.2: Import Dataset wizard in RStudio "],
["3-r-programming-short-introduction.html", "Chapter 3 R Programming - Short Introduction", " Chapter 3 R Programming - Short Introduction you might not think that programmers are artists, but programming is an extremely creative profession. It’s logic-based creativity. -John Romero Here we will cover the basic structures of R programming, including control flow (if else) and loops (iteration routines) followed by writing our first function. We will confine our discussion to the beginner’s level. "],
["3-1-programming-control-flow.html", "3.1 Programming Control Flow", " 3.1 Programming Control Flow Control flow (or flow control) is a well defined sequence of conditional statements, loops and statements which directs the R script (or code in generalised sense) to execute one thing or the other based on the conditions written in the program. 3.1.1 if-else Conditional Statements We use if-else conditional statements when we want the R program to branch out in different directions based on a logical condition. The following example compares the mean of two stocks and assigns a variable with the greater mean. data_stocks = read.csv(&quot;data/us_stocks.csv&quot;) # remove NAs from the data data_stocks = na.omit(data_stocks) m_msft = mean(data_stocks$MSFT) m_aapl = mean(data_stocks$AAPL) if (m_msft &gt; m_aapl) { g_mean = m_msft message(&quot;Msft mean is higher&quot;) } else { g_mean = m_aapl message(&quot;Aapl mean is higher&quot;) } g_mean #print greater mean [1] 207.7967 The if-else also works as a function call, the if-else call in the example above can be reduced to one line as follows. Note that the curly brackets in case of just one statement are optional. They are required in case of a block operation. Its easy to just use them to avoid confusion. R also has a function \\(\\mathtt{ifelse}\\) which does the same operation as in example above. See \\(\\mathtt{help(ifelse)}\\) for more details # arguments to ifelse args(ifelse) function (test, yes, no) NULL g_mean = ifelse(m_msft &gt; m_aapl, m_msft, m_aapl) g_mean [1] 207.7967 3.1.2 Loops Loops are the common feature in almost all the programming languages. R provides three basic loops using \\(\\mathtt{for}\\), \\(\\mathtt{while}\\) and \\(\\mathtt{repeat}\\). # construct the loop j = 0 for (i in 1:15) { j = j + i #add i to j print(j) #print the sequential sum } [1] 1 [1] 3 [1] 6 [1] 10 [1] 15 [1] 21 [1] 28 [1] 36 [1] 45 [1] 55 [1] 66 [1] 78 [1] 91 [1] 105 [1] 120 3.1.3 \\(\\mathtt{while}\\) loop \\(\\mathtt{while}\\) loop evaluates an expression or a function while a condition is TRUE. Lets repeat the above example using \\(\\mathtt{while}\\) loop # intialise j and i j = 0 i = 1 # one can also use i&lt;=15 while (i &lt; 16) { j = j + i i = i + 1 print(j) } [1] 1 [1] 3 [1] 6 [1] 10 [1] 15 [1] 21 [1] 28 [1] 36 [1] 45 [1] 55 [1] 66 [1] 78 [1] 91 [1] 105 [1] 120 3.1.4 \\(\\mathtt{repeat}\\) loop \\(\\mathtt{repeat}\\) repeats the same expression till it is broken due to a condition. # intialize j = 0 i = 1 repeat { j = j + i i = i + 1 print(j) if (i &gt; 15) break } [1] 1 [1] 3 [1] 6 [1] 10 [1] 15 [1] 21 [1] 28 [1] 36 [1] 45 [1] 55 [1] 66 [1] 78 [1] 91 [1] 105 [1] 120 Together all these three loops can be used for iterative operations. The loops come handy when you have to iterate medium to large data by row or column.6 Using simple loops can be resource intensive for large datasets or operations. There are other approaches such as using iterative functions like \\(\\mathtt{lapply, sapply}\\) etc or parallel computing methods to get better results in such cases.↩︎ "],
["3-2-functions-in-r.html", "3.2 Functions in R", " 3.2 Functions in R In all research fields there are few statistical (or otherwise) calculations which are used frequently by the users, for example calculation of returns in finance research. R provides the facility of creating specific functions to evaluate a set of arguments and return an output value which are stored as R objects. The functions in R are created by the keyword \\(\\mathtt{function}\\) which takes the following syntax. \\[\\mathtt{function(arguments)}body\\] The arguments are the values/defaults/variables which are used in the body of the function to evaluate an expression. The body of the function is enclosed in curly braces. The function is assigned to a named object and called by passing arguments to the object. The following example illustrates by creating a function to calculate mean for all the columns in the data set \\(\\mathtt{data\\_stocks}\\) # the following function takes 2 arguments, x a data frame, dates to indicate if # there are dates in the first column cal_mean = function(x, dates = TRUE) { num_cols = ncol(x) #calculate the number of columns # num_cols=ifelse(dates==TRUE,num_cals-1,num_cals) lets use a list and a loop to # refresh our concepts m_stocks = list() #creating an empty list # use for loop assign the starting value based on the dates column,we skip dates # column if they are present (dates are basically row names to more generalised # version will be to check for row names) l = ifelse(dates == TRUE, 2, 1) j = 1 #starting point in the list m_stocks for (i in l:num_cols) { m_stocks[[j]] = mean(x[, i]) j = j + 1 } names(m_stocks) = colnames(x[, l:num_cols]) return(m_stocks) } # lets call the function cal_mean (output not shown) cal_mean(data_stocks, TRUE) $MSFT [1] 26.91177 $IBM [1] 122.3303 $AAPL [1] 207.7967 $MCD [1] 58.95141 $PG [1] 61.32512 $GOOG [1] 469.9453 # lets call the function with no dates column cal_mean(data_stocks[, 2:ncol(data_stocks)], FALSE) $MSFT [1] 26.91177 $IBM [1] 122.3303 $AAPL [1] 207.7967 $MCD [1] 58.95141 $PG [1] 61.32512 $GOOG [1] 469.9453 "],
["4-data-exploration.html", "Chapter 4 Data Exploration", " Chapter 4 Data Exploration The good news is that these descriptive statistics give us a manageable and meaningful summary of the underlying phenomenon. That’s what this chapter is about. The bad news is that any simplification invites abuse. Descriptive statistics can be like online dating profiles: technically accurate and yet pretty darn misleading. -Charles Wheelan "],
["4-1-data-preprocessing.html", "4.1 Data Preprocessing", " 4.1 Data Preprocessing -We will now discuss some methods for data manipulation to clean a dataset, combine various datasets or extract a variable from a data frame before we jump into some programming basics. 4.1.1 Extracting Data -Data frames are the most used data structures in R as they offer more flexibility in the way they can handle data. Lets see some methods to extract data from a data frame. We will use the example dataset called \\(\\mathtt{us\\_stocks.csv}\\). Lets import it using \\(\\mathtt{read.csv}\\) data_stocks = read.csv(file = &quot;data/us_stocks.csv&quot;, header = TRUE) head(data_stocks) Date MSFT IBM AAPL MCD PG GOOG 1 2/01/2002 33.52 121.50 11.65 26.49 40.00 NA 2 3/01/2002 34.62 123.66 11.79 26.79 39.62 NA 3 4/01/2002 34.45 125.60 11.84 26.99 39.22 NA 4 7/01/2002 34.28 124.05 11.45 27.20 38.78 NA 5 8/01/2002 34.69 124.70 11.30 27.36 38.88 NA 6 9/01/2002 34.36 124.49 10.82 26.88 38.60 NA The function \\(\\mathtt{names}\\) or \\(\\mathtt{colnames}\\) are used to access the names of the columns (or variables) in the data set as shows below. The function \\(\\mathtt{row.names}\\) can be used to access row names (if any) from a dataset names(data_stocks) [1] &quot;Date&quot; &quot;MSFT&quot; &quot;IBM&quot; &quot;AAPL&quot; &quot;MCD&quot; &quot;PG&quot; &quot;GOOG&quot; colnames(data_stocks) [1] &quot;Date&quot; &quot;MSFT&quot; &quot;IBM&quot; &quot;AAPL&quot; &quot;MCD&quot; &quot;PG&quot; &quot;GOOG&quot; A specific data variable can be accessed using its name or index (column number) in the data frame. To select any column use \\(\\mathtt{\\$}\\) symbol followed by the column name or its name in square brackets as shown in the example below msft_prices1 = data_stocks$MSFT #the data is returned as a vector head(msft_prices1) [1] 33.52 34.62 34.45 34.28 34.69 34.36 msft_prices2 = data_stocks[[&quot;MSFT&quot;]] #the data is returned as a vector head(msft_prices2) [1] 33.52 34.62 34.45 34.28 34.69 34.36 # the following returns data as a data frame msft_prices3 = data_stocks[&quot;MSFT&quot;] #can also be used to access multiple columns head(msft_prices3) MSFT 1 33.52 2 34.62 3 34.45 4 34.28 5 34.69 6 34.36 These data columns can also be accessed like a matrix, using a matrix index. This method can return a complete row, a complete column or just an element from the dataset. # MSFT is in the second column and leaving the row index blank returns all the # rows for the particular column msft_prices4 = data_stocks[, 2] head(msft_prices4) [1] 33.52 34.62 34.45 34.28 34.69 34.36 # all the elements in row 4 data_stocks[4, ] Date MSFT IBM AAPL MCD PG GOOG 4 7/01/2002 34.28 124.05 11.45 27.2 38.78 NA 4.1.2 Combining Data Frames It may be required to combine two data frames during a data processing. This can be done by stacking them row by row or combining them by columns using \\(\\mathtt{rbind}\\) and \\(\\mathtt{cbind}\\) respectively. When using \\(\\mathtt{cbind}\\) the number of rows in the columns combined must be of equal length likewise in \\(\\mathtt{rbind}\\) the number of columns of the datasets combined should be equal. Lets see an example # First create a vector having the returns for msft msft_ret = 100 * diff(log(data_stocks$MSFT)) # combine the vector with the data data_stocks_r = cbind(data_stocks, MSFT_RET = msft_ret) #this will generate an error message Error in data.frame(..., check.names = FALSE): arguments imply differing number of rows: 2784, 2783 # different length length(msft_ret) [1] 2783 length(data_stocks$MSFT) [1] 2784 # add one more value to vector msft_ret msft_ret = c(0, msft_ret) # check the length length(msft_ret) [1] 2784 # lets combine now (it should work) data_stocks_r = cbind(data_stocks, MSFT_RET = msft_ret) head(data_stocks_r) #shows one more column added to the data Date MSFT IBM AAPL MCD PG GOOG MSFT_RET 1 2/01/2002 33.52 121.50 11.65 26.49 40.00 NA 0.0000000 2 3/01/2002 34.62 123.66 11.79 26.79 39.62 NA 3.2289274 3 4/01/2002 34.45 125.60 11.84 26.99 39.22 NA -0.4922552 4 7/01/2002 34.28 124.05 11.45 27.20 38.78 NA -0.4946904 5 8/01/2002 34.69 124.70 11.30 27.36 38.88 NA 1.1889367 6 9/01/2002 34.36 124.49 10.82 26.88 38.60 NA -0.9558364 The following example adds a row to the data frame. # create two dataframes from data_stocks data_r1 = data_stocks[1:10, ] #first 10 rows data_r2 = data_stocks[2775:2784, ] #last 10 rows data_stocks_rbind = rbind(data_r1, data_r2) print(data_stocks_rbind) Date MSFT IBM AAPL MCD PG GOOG 1 2/01/2002 33.52 121.50 11.65 26.49 40.00 NA 2 3/01/2002 34.62 123.66 11.79 26.79 39.62 NA 3 4/01/2002 34.45 125.60 11.84 26.99 39.22 NA 4 7/01/2002 34.28 124.05 11.45 27.20 38.78 NA 5 8/01/2002 34.69 124.70 11.30 27.36 38.88 NA 6 9/01/2002 34.36 124.49 10.82 26.88 38.60 NA 7 10/01/2002 34.64 122.14 10.62 26.81 38.46 NA 8 11/01/2002 34.30 120.31 10.52 26.34 38.60 NA 9 14/01/2002 34.24 118.05 10.58 26.02 39.35 NA 10 15/01/2002 34.78 118.85 10.85 26.20 39.82 NA 2775 17/12/2012 27.10 193.62 518.83 89.91 69.93 720.78 2776 18/12/2012 27.56 195.69 533.90 90.52 69.97 721.07 2777 19/12/2012 27.31 195.08 526.31 89.71 69.34 720.11 2778 20/12/2012 27.68 194.77 521.73 90.04 69.82 722.36 2779 21/12/2012 27.45 193.42 519.33 90.18 68.72 715.63 2780 24/12/2012 27.06 192.40 520.17 89.29 68.52 709.50 2781 26/12/2012 26.86 191.95 513.00 88.74 68.00 708.87 2782 27/12/2012 26.96 192.71 515.06 88.72 67.97 706.29 2783 28/12/2012 26.55 189.83 509.59 87.58 67.15 700.01 2784 31/12/2012 26.71 191.55 532.17 88.21 67.89 707.38 4.1.3 Sub setting and Logical Data Selection Suppose we want to extract data with particular characteristics like values ranges etc. This can be accomplished using logical statements in bracket notations. The following example illustrates. See \\(\\mathtt{help(&quot;&gt;&quot;)}\\) to see more comparison operators. # select all rows with Apple prices above 100 data_aaplgr100 = data_stocks[data_stocks$AAPL &gt; 100, ] head(data_aaplgr100) Date MSFT IBM AAPL MCD PG GOOG 1342 2/05/2007 30.61 102.22 100.39 50.02 62.37 465.78 1343 3/05/2007 30.97 102.80 100.40 49.91 62.00 473.23 1344 4/05/2007 30.56 102.96 100.81 49.92 62.41 471.12 1345 7/05/2007 30.71 103.16 103.92 49.50 62.18 467.27 1346 8/05/2007 30.75 103.29 105.06 49.32 61.75 466.81 1347 9/05/2007 30.78 104.38 106.88 49.84 62.01 469.25 min(data_aaplgr100$AAPL) #check if the prices are above 100 [1] NA # this give NA as the minimum which indicates that data frame has NA lets remove # NAs from data_aaplgr100 using na.omit function data_aaplgr100 = na.omit(data_aaplgr100) # now check the minimum again min(data_aaplgr100$AAPL) [1] 100.06 The \\(\\mathtt{na.omit}\\) function used in the example above can be used to remove all the empty values in the dataset. head(data_stocks) #notice NAs in GOOG Date MSFT IBM AAPL MCD PG GOOG 1 2/01/2002 33.52 121.50 11.65 26.49 40.00 NA 2 3/01/2002 34.62 123.66 11.79 26.79 39.62 NA 3 4/01/2002 34.45 125.60 11.84 26.99 39.22 NA 4 7/01/2002 34.28 124.05 11.45 27.20 38.78 NA 5 8/01/2002 34.69 124.70 11.30 27.36 38.88 NA 6 9/01/2002 34.36 124.49 10.82 26.88 38.60 NA data_stocks_googlena = data_stocks[!is.na(data_stocks$GOOG), ] head(data_stocks_googlena) #after removing NAs Date MSFT IBM AAPL MCD PG GOOG 663 19/08/2004 27.12 84.89 15.36 26.60 54.48 100.34 664 20/08/2004 27.20 85.25 15.40 27.07 54.85 108.31 665 23/08/2004 27.24 84.65 15.54 26.64 54.75 109.40 666 24/08/2004 27.24 84.71 15.98 26.87 54.95 104.87 667 25/08/2004 27.55 85.07 16.52 26.95 55.30 106.00 668 26/08/2004 27.44 84.69 17.33 27.10 55.70 107.91 # the above can still leave NAs in other columns use na.omit to remove all the # blank data data_stocks_naomit = na.omit(data_stocks) There can be a requirement in data pre processing where one might have to select data in a range. The following example selects data where MSFT prices lie between 20 and 30. \\(\\mathtt{\\&amp;}\\) is a Logic operator in R see help(“&amp;”) to see more details and other Logic operators. data_msft = data_stocks_naomit[data_stocks_naomit$MSFT &lt;= 30 &amp; data_stocks_naomit$MSFT &gt; 20, ] min(data_msft$MSFT) #check [1] 20.06 These selections can also be performed using the function \\(\\mathtt{subset}\\). The following example uses \\(\\mathtt{subset}\\) function to select rows with AAPL&gt;100. The arguments to the function are also shows in the example args(subset.data.frame) function (x, subset, select, drop = FALSE, ...) NULL aaplgr100 = subset(data_stocks_naomit, AAPL &gt; 100) head(aaplgr100) Date MSFT IBM AAPL MCD PG GOOG 1342 2/05/2007 30.61 102.22 100.39 50.02 62.37 465.78 1343 3/05/2007 30.97 102.80 100.40 49.91 62.00 473.23 1344 4/05/2007 30.56 102.96 100.81 49.92 62.41 471.12 1345 7/05/2007 30.71 103.16 103.92 49.50 62.18 467.27 1346 8/05/2007 30.75 103.29 105.06 49.32 61.75 466.81 1347 9/05/2007 30.78 104.38 106.88 49.84 62.01 469.25 min(aaplgr100$AAPL) [1] 100.06 "],
["4-2-data-transformation-from-wide-to-long-or-vice-versa.html", "4.2 Data Transformation from Wide to Long (or vice versa)", " 4.2 Data Transformation from Wide to Long (or vice versa) Sometimes its required to transform wide format data to long, which is often required to work with ggplot2 package (discussed in the graphics section) R package tidyr provides two functions pivot_longer() and pivot_wider() to transform the data into long or wide format. Let’s convert the stocks data to the long format library(tidyr) FinData_long = pivot_longer(data = data_stocks, cols = -Date, names_to = &quot;Stock&quot;, values_to = &quot;Price&quot;) head(FinData_long) # A tibble: 6 x 3 Date Stock Price &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 2/01/2002 MSFT 33.5 2 2/01/2002 IBM 122. 3 2/01/2002 AAPL 11.6 4 2/01/2002 MCD 26.5 5 2/01/2002 PG 40 6 2/01/2002 GOOG NA A reverse operation can be conducted using pivot_wider() FinData_wide = pivot_wider(FinData_long, names_from = Stock, values_from = Price) head(FinData_wide) # A tibble: 6 x 7 Date MSFT IBM AAPL MCD PG GOOG &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 2/01/2002 33.5 122. 11.6 26.5 40 NA 2 3/01/2002 34.6 124. 11.8 26.8 39.6 NA 3 4/01/2002 34.4 126. 11.8 27.0 39.2 NA 4 7/01/2002 34.3 124. 11.4 27.2 38.8 NA 5 8/01/2002 34.7 125. 11.3 27.4 38.9 NA 6 9/01/2002 34.4 124. 10.8 26.9 38.6 NA "],
["4-3-summary-statistics.html", "4.3 Summary Statistics", " 4.3 Summary Statistics The good news is that these descriptive statistics give us a manageable and meaningful summary of the underlying phenomenon. That’s what this chapter is about. The bad news is that any simplification invites abuse. Descriptive statistics can be like online dating profiles: technically accurate and yet pretty darn misleading.-Charles Wheelan It is simple to calculate basic summary statistics in R, most of the functions are named according to what they do. For instance \\(\\mathtt{mean}\\) calculates the mean of a single variable, \\(\\mathtt{sd}\\) calculates the standard deviation. Table: Basic statistics functions in R Statistics R-Function Arithmetic mean mean( x ) Geometric mean exp( mean( log( x ) ) ) median median( x ) Range range( x ) variance var( x ) standard deviation sd( x ) Interquantile Range IQR( x ) Other quantiles quantile( x ) Skewness skewness( x ) Kurtosis kurtosis( x ) The following example demonstrates how to calculate the statistics measures in table-1 for Dow Jones prices in data file data_fin.csv # change the working directory to the folder containing data_fin.csv or provide # the full path with the filename data_stocks = read.csv(&quot;data/data_fin.csv&quot;) #import data head(data_stocks) Date DJI AXP MMM ATT BA CAT CISCO DD XOM GE 1 3/01/2000 11357.5 45.82 47.19 47.19 40.12 24.31 54.05 65.00 39.09 49.95 2 4/01/2000 10997.9 44.09 45.31 44.25 40.12 24.00 51.00 65.00 38.41 48.06 3 5/01/2000 11122.7 42.96 46.62 44.94 42.62 24.56 51.19 67.75 40.50 47.70 4 6/01/2000 11253.3 43.78 50.62 43.75 43.06 25.81 50.00 71.50 42.59 48.51 5 7/01/2000 11522.6 44.42 51.47 44.12 44.12 26.66 52.94 71.62 42.31 50.28 6 10/01/2000 11572.2 45.04 51.12 44.75 43.69 25.78 54.91 70.00 41.88 50.37 GS HD IBM INTC JNJ JPM MRK MCD MSFT NKE 1 88.31 65.50 115.56 43.47 46.09 48.69 64.04 39.62 58.34 12.03 2 82.38 61.50 112.06 41.47 44.41 47.27 61.61 38.81 56.31 11.38 3 78.88 61.44 116.00 41.81 44.88 46.98 64.22 39.44 56.91 12.03 4 82.25 60.00 114.62 39.38 46.28 47.65 64.75 38.88 55.00 11.97 5 82.56 62.81 113.31 41.00 47.88 48.52 70.97 39.75 55.72 11.97 6 84.38 63.19 118.44 42.88 47.03 47.69 68.89 40.06 56.12 12.17 DJI = data_stocks$DJI DJI = na.omit(DJI) #remove NAs as it will affect the calculations # Arithmetic mean mean(DJI) [1] 11098.12 # Geometric mean exp(mean(log(DJI))) [1] 10953.39 # median median(DJI) [1] 10748.8 # variance &amp; standard deviation var(DJI) [1] 3280347 sd(DJI) [1] 1811.173 # interquantile range and few quantiles IQR(DJI) [1] 2276.25 quantile(DJI) 0% 25% 50% 75% 100% 6547.10 10063.25 10748.80 12339.50 16576.66 # skewness and kurtosis skewness and kurtosis functions are not available in R # core library but in library e1071 (there are other packages which have # functions for skewness and kurtosis try ??kurtosis or search for the function # on RSearch. library(e1071) skewness(DJI) [1] 0.4777828 kurtosis(DJI) [1] 0.08404185 The function \\(\\mathtt{summary}\\) in R provides some basic summary viz., minimum value, maximum value, median value and quartiles for one variable or a dataset. The function \\(\\mathtt{summary}\\) can be used as follows # summary of one column/variable in a dataframe summary(DJI) Min. 1st Qu. Median Mean 3rd Qu. Max. 6547 10063 10749 11098 12340 16577 # summary of whole dataset excluding the time column summary(data_stocks[, c(2:21)]) DJI AXP MMM ATT Min. : 6547 Min. :10.26 Min. : 39.50 Min. :19.34 1st Qu.:10063 1st Qu.:38.31 1st Qu.: 62.55 1st Qu.:25.54 Median :10749 Median :47.49 Median : 77.67 Median :29.65 Mean :11098 Mean :46.77 Mean : 75.78 Mean :31.77 3rd Qu.:12340 3rd Qu.:54.44 3rd Qu.: 85.55 3rd Qu.:37.22 Max. :16577 Max. :90.73 Max. :140.25 Max. :58.50 NA&#39;s :27 NA&#39;s :12 NA&#39;s :12 NA&#39;s :12 BA CAT CISCO DD Min. : 25.06 Min. : 14.91 Min. : 8.60 Min. :16.14 1st Qu.: 44.00 1st Qu.: 28.64 1st Qu.:17.68 1st Qu.:41.13 Median : 63.56 Median : 57.10 Median :20.43 Median :44.53 Mean : 62.95 Mean : 56.01 Mean :23.41 Mean :44.37 3rd Qu.: 74.90 3rd Qu.: 79.36 3rd Qu.:24.17 3rd Qu.:48.92 Max. :138.36 Max. :116.20 Max. :80.06 Max. :71.62 NA&#39;s :12 NA&#39;s :12 NA&#39;s :13 NA&#39;s :12 XOM GE GS HD Min. : 30.27 Min. : 6.66 Min. : 52.0 Min. :18.00 1st Qu.: 42.46 1st Qu.:20.00 1st Qu.: 92.2 1st Qu.:31.00 Median : 64.77 Median :30.33 Median :116.2 Median :37.37 Mean : 63.20 Mean :29.56 Mean :126.9 Mean :40.20 3rd Qu.: 81.62 3rd Qu.:36.03 3rd Qu.:159.5 3rd Qu.:46.23 Max. :101.51 Max. :59.94 Max. :247.9 Max. :82.34 NA&#39;s :12 NA&#39;s :12 NA&#39;s :12 NA&#39;s :12 IBM INTC JNJ JPM Min. : 55.07 Min. :12.08 Min. :33.69 Min. :15.45 1st Qu.: 87.82 1st Qu.:20.17 1st Qu.:55.27 1st Qu.:35.66 Median :106.48 Median :22.76 Median :61.30 Median :40.20 Mean :118.83 Mean :25.21 Mean :61.07 Mean :40.36 3rd Qu.:130.00 3rd Qu.:26.77 3rd Qu.:65.20 3rd Qu.:45.71 Max. :215.80 Max. :74.88 Max. :95.63 Max. :65.70 NA&#39;s :12 NA&#39;s :13 NA&#39;s :12 NA&#39;s :12 MRK MCD MSFT NKE Min. :20.99 Min. : 12.38 Min. :15.15 Min. : 6.64 1st Qu.:34.53 1st Qu.: 29.19 1st Qu.:25.67 1st Qu.:14.56 Median :43.63 Median : 43.78 Median :27.59 Median :23.25 Mean :44.65 Mean : 51.07 Mean :28.38 Mean :28.01 3rd Qu.:51.55 3rd Qu.: 70.36 3rd Qu.:30.19 3rd Qu.:36.90 Max. :89.85 Max. :103.59 Max. :58.34 Max. :79.86 NA&#39;s :13 NA&#39;s :12 NA&#39;s :13 NA&#39;s :12 4.3.1 Example-Descriptive Statistics of Stock Returns In this example we will use R to calculate descriptive statistics for the returns of 10 stocks in the data file \\(\\mathtt{data\\_fin.csv}\\). • We will first import the dataset into R using the \\(\\mathtt{read.csv}\\) function. data_cs1 = read.csv(&quot;data/data_fin.csv&quot;) head(data_cs1) #check the imported data Date DJI AXP MMM ATT BA CAT CISCO DD XOM GE 1 3/01/2000 11357.5 45.82 47.19 47.19 40.12 24.31 54.05 65.00 39.09 49.95 2 4/01/2000 10997.9 44.09 45.31 44.25 40.12 24.00 51.00 65.00 38.41 48.06 3 5/01/2000 11122.7 42.96 46.62 44.94 42.62 24.56 51.19 67.75 40.50 47.70 4 6/01/2000 11253.3 43.78 50.62 43.75 43.06 25.81 50.00 71.50 42.59 48.51 5 7/01/2000 11522.6 44.42 51.47 44.12 44.12 26.66 52.94 71.62 42.31 50.28 6 10/01/2000 11572.2 45.04 51.12 44.75 43.69 25.78 54.91 70.00 41.88 50.37 GS HD IBM INTC JNJ JPM MRK MCD MSFT NKE 1 88.31 65.50 115.56 43.47 46.09 48.69 64.04 39.62 58.34 12.03 2 82.38 61.50 112.06 41.47 44.41 47.27 61.61 38.81 56.31 11.38 3 78.88 61.44 116.00 41.81 44.88 46.98 64.22 39.44 56.91 12.03 4 82.25 60.00 114.62 39.38 46.28 47.65 64.75 38.88 55.00 11.97 5 82.56 62.81 113.31 41.00 47.88 48.52 70.97 39.75 55.72 11.97 6 84.38 63.19 118.44 42.88 47.03 47.69 68.89 40.06 56.12 12.17 Apply function to with dates as character and then after converting dates to Date class. # selecting first 10 price series including the data column data_cs1.1 = data_cs1[, c(1:11)] # data cleaning-remove NAs data_cs1.1 = na.omit(data_cs1.1) colnames(data_cs1.1) # see the columns present in the data [1] &quot;Date&quot; &quot;DJI&quot; &quot;AXP&quot; &quot;MMM&quot; &quot;ATT&quot; &quot;BA&quot; &quot;CAT&quot; &quot;CISCO&quot; &quot;DD&quot; [10] &quot;XOM&quot; &quot;GE&quot; summary(data_cs1.1) #notice the Date variable Date DJI AXP MMM Length:3523 Min. : 6547 Min. :10.26 Min. : 39.50 Class :character 1st Qu.:10063 1st Qu.:38.38 1st Qu.: 62.55 Mode :character Median :10749 Median :47.60 Median : 77.67 Mean :11098 Mean :46.83 Mean : 75.80 3rd Qu.:12340 3rd Qu.:54.50 3rd Qu.: 85.61 Max. :16577 Max. :90.73 Max. :140.25 ATT BA CAT CISCO Min. :19.34 Min. : 25.06 Min. : 14.91 Min. : 8.60 1st Qu.:25.54 1st Qu.: 44.02 1st Qu.: 28.48 1st Qu.:17.68 Median :29.76 Median : 63.61 Median : 57.11 Median :20.39 Mean :31.79 Mean : 62.99 Mean : 56.03 Mean :23.42 3rd Qu.:37.23 3rd Qu.: 74.95 3rd Qu.: 79.50 3rd Qu.:24.18 Max. :58.50 Max. :138.36 Max. :116.20 Max. :80.06 DD XOM GE Min. :16.14 Min. : 30.27 Min. : 6.66 1st Qu.:41.17 1st Qu.: 42.41 1st Qu.:20.04 Median :44.58 Median : 64.70 Median :30.37 Mean :44.43 Mean : 63.18 Mean :29.63 3rd Qu.:48.93 3rd Qu.: 81.70 3rd Qu.:36.05 Max. :71.62 Max. :101.51 Max. :59.94 # check class of dates which will be factor ( treated as factor by default) class(data_cs1.1$Date) [1] &quot;character&quot; # convert dates to class Date data_cs1.1$Date = as.Date(data_cs1.1$Date, format = &quot;%d/%m/%Y&quot;) class(data_cs1.1$Date) [1] &quot;Date&quot; summary(data_cs1.1) #notice the Date variable Date DJI AXP MMM Min. :2000-01-03 Min. : 6547 Min. :10.26 Min. : 39.50 1st Qu.:2003-07-08 1st Qu.:10063 1st Qu.:38.38 1st Qu.: 62.55 Median :2007-01-05 Median :10749 Median :47.60 Median : 77.67 Mean :2007-01-03 Mean :11098 Mean :46.83 Mean : 75.80 3rd Qu.:2010-07-06 3rd Qu.:12340 3rd Qu.:54.50 3rd Qu.: 85.61 Max. :2014-01-03 Max. :16577 Max. :90.73 Max. :140.25 ATT BA CAT CISCO Min. :19.34 Min. : 25.06 Min. : 14.91 Min. : 8.60 1st Qu.:25.54 1st Qu.: 44.02 1st Qu.: 28.48 1st Qu.:17.68 Median :29.76 Median : 63.61 Median : 57.11 Median :20.39 Mean :31.79 Mean : 62.99 Mean : 56.03 Mean :23.42 3rd Qu.:37.23 3rd Qu.: 74.95 3rd Qu.: 79.50 3rd Qu.:24.18 Max. :58.50 Max. :138.36 Max. :116.20 Max. :80.06 DD XOM GE Min. :16.14 Min. : 30.27 Min. : 6.66 1st Qu.:41.17 1st Qu.: 42.41 1st Qu.:20.04 Median :44.58 Median : 64.70 Median :30.37 Mean :44.43 Mean : 63.18 Mean :29.63 3rd Qu.:48.93 3rd Qu.: 81.70 3rd Qu.:36.05 Max. :71.62 Max. :101.51 Max. :59.94 Convert prices to returns d2 = as.data.frame(sapply(data_cs1.1[2:11], function(x) diff(log(x)) * 100)) #note it will be one less # create a different dataframe with returns data_stocks_ret = as.data.frame(cbind(Date = data_cs1.1$Date[2:length(data_cs1.1$Date)], d2), stringsAsFactors = FALSE, row.names = NULL) # visual inspection head(data_stocks_ret) Date DJI AXP MMM ATT BA CAT 1 2000-01-04 -3.2173973 -3.8487678 -4.0654247 -6.4326634 0.0000000 -1.283396 2 2000-01-05 1.1283720 -2.5963549 2.8501875 1.5472895 6.0448664 2.306527 3 2000-01-06 1.1673354 1.8907642 8.2317122 -2.6836654 1.0270865 4.964291 4 2000-01-07 2.3648905 1.4512726 1.6652359 0.8421582 2.4318702 3.240230 5 2000-01-10 0.4295346 1.3861165 -0.6823304 1.4178250 -0.9793951 -3.356532 6 2000-01-11 -0.5293883 0.9061837 -1.7165263 -1.4178250 -1.8713726 -1.563754 CISCO DD XOM GE 1 -5.8083911 0.0000000 -1.7548837 -3.8572275 2 0.3718568 4.1437190 5.2984132 -0.7518832 3 -2.3521195 5.3872990 5.0317510 1.6838564 4 5.7136191 0.1676915 -0.6596019 3.5837421 5 3.6536284 -2.2879123 -1.0215079 0.1788376 6 -3.0697677 -1.8018506 1.1868167 0.2379537 4.3.1.1 Using the \\(\\mathtt{describe}\\) function The package psych comes with a function called \\(\\mathtt{describe}\\) which generated the descriptive statistics for all the data vectors (columns) in a data frame, matrix or a vector. library(psych) #load the required package args(describe) #arguments for describe function function (x, na.rm = TRUE, interp = FALSE, skew = TRUE, ranges = TRUE, trim = 0.1, type = 3, check = TRUE, fast = NULL, quant = NULL, IQR = FALSE, omit = FALSE) NULL # use describe to calculate descriptive stats for data_cs1.1r desc1 = describe(data_stocks_ret[, 2:11]) #note we dont pass the date column # check the output head(desc1) vars n mean sd median trimmed mad min max range skew kurtosis DJI 1 3522 0.01 1.23 0.04 0.03 0.82 -8.20 10.51 18.71 -0.06 7.71 AXP 2 3522 0.02 2.89 0.02 0.03 1.55 -19.35 18.77 38.12 -0.01 9.14 MMM 3 3522 0.03 1.55 0.03 0.03 1.10 -9.38 10.39 19.78 0.06 4.87 ATT 4 3522 -0.01 1.80 0.03 0.01 1.22 -13.54 15.08 28.62 0.02 6.26 BA 5 3522 0.03 2.01 0.05 0.06 1.57 -19.39 14.38 33.77 -0.26 5.39 CAT 6 3522 0.04 2.14 0.04 0.05 1.65 -15.69 13.73 29.42 -0.08 4.08 se DJI 0.02 AXP 0.05 MMM 0.03 ATT 0.03 BA 0.03 CAT 0.04 # the above output is in long format, we can transpose it get column format desc1.t = t(desc1) head(desc1.t) DJI AXP MMM ATT BA vars 1.000000e+00 2.000000e+00 3.000000e+00 4.000000e+00 5.000000e+00 n 3.522000e+03 3.522000e+03 3.522000e+03 3.522000e+03 3.522000e+03 mean 1.055257e-02 1.908563e-02 3.056011e-02 -8.647491e-03 3.499777e-02 sd 1.226702e+00 2.892586e+00 1.551706e+00 1.799180e+00 2.013123e+00 median 4.442671e-02 1.723604e-02 3.233787e-02 3.018428e-02 5.279680e-02 trimmed 2.597511e-02 3.152635e-02 3.241946e-02 9.134423e-03 5.567097e-02 CAT CISCO DD XOM GE vars 6.000000e+00 7.000000e+00 8.000000e+00 9.000000e+00 1.000000e+01 n 3.522000e+03 3.522000e+03 3.522000e+03 3.522000e+03 3.522000e+03 mean 3.710732e-02 -2.554732e-02 -5.379787e-04 2.653014e-02 -1.696661e-02 sd 2.143040e+00 2.744068e+00 1.881993e+00 1.629181e+00 2.057353e+00 median 4.291300e-02 3.800312e-02 0.000000e+00 5.437650e-02 0.000000e+00 trimmed 4.678016e-02 -1.339579e-04 1.469270e-03 4.883990e-02 9.841473e-05 The descriptive statistics generated above gives mean, median, standard deviation, trimmed mean(trimmed), median, mad (median absolute deviation from the median), minimum (min), maximum (max), skewness (skew), kurtosis and standard error (se) . This can easily be transferred to a CSV file or a text file. The following single line of code transfers the descriptive statistics to a CSV file which then can be imported into a word or latex file as required. The pastecs package provides the function \\(\\mathtt{stat.desc}\\) which generated descriptive statistics for a data frame, matrix or a timeseries. Skewness and Kurtosis are not calculated by default in \\(\\mathtt{stat.desc}\\) but the argument \\(\\mathtt{norm}\\) can be set to TRUE to get these measures along with their standard errors. require(pastecs) # note library and require can both be used to include a package # detach the package pastecs its useful to avoid any conflicts (e.g psych and # Hmisc have &#39;describe&#39; function with two different behaviours detach(&quot;package:psych&quot;, unload = TRUE) # use stat.desc in with default arguments desc2 = stat.desc(data_stocks_ret[, 2:11], norm = TRUE) desc2 #note skewness/kurtosis DJI AXP MMM ATT nbr.val 3.522000e+03 3.522000e+03 3.522000e+03 3.522000e+03 nbr.null 2.000000e+00 2.400000e+01 3.000000e+01 5.000000e+01 nbr.na 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 min -8.200737e+00 -1.935233e+01 -9.383688e+00 -1.353821e+01 max 1.050812e+01 1.877116e+01 1.039309e+01 1.508318e+01 range 1.870886e+01 3.812349e+01 1.977678e+01 2.862139e+01 sum 3.716616e+01 6.721959e+01 1.076327e+02 -3.045646e+01 median 4.442671e-02 1.723604e-02 3.233787e-02 3.018428e-02 mean 1.055257e-02 1.908563e-02 3.056011e-02 -8.647491e-03 SE.mean 2.067018e-02 4.874068e-02 2.614656e-02 3.031656e-02 CI.mean.0.95 4.052675e-02 9.556282e-02 5.126395e-02 5.943979e-02 var 1.504798e+00 8.367052e+00 2.407790e+00 3.237048e+00 std.dev 1.226702e+00 2.892586e+00 1.551706e+00 1.799180e+00 coef.var 1.162467e+02 1.515583e+02 5.077551e+01 -2.080580e+02 skewness -5.829983e-02 -6.689750e-03 5.927112e-02 1.620418e-02 skew.2SE -7.065472e-01 -8.107441e-02 7.183185e-01 1.963817e-01 kurtosis 7.714304e+00 9.141053e+00 4.865294e+00 6.257155e+00 kurt.2SE 4.675883e+01 5.540681e+01 2.949008e+01 3.792659e+01 normtest.W 9.187712e-01 8.496717e-01 9.384591e-01 9.298653e-01 normtest.p 5.671566e-40 1.020339e-49 6.131053e-36 8.237017e-38 BA CAT CISCO DD nbr.val 3.522000e+03 3.522000e+03 3.522000e+03 3.522000e+03 nbr.null 1.500000e+01 2.400000e+01 5.000000e+01 2.900000e+01 nbr.na 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 min -1.938931e+01 -1.568589e+01 -1.768649e+01 -1.202802e+01 max 1.437774e+01 1.373497e+01 2.182386e+01 1.085590e+01 range 3.376704e+01 2.942086e+01 3.951034e+01 2.288392e+01 sum 1.232621e+02 1.306920e+02 -8.997766e+01 -1.894761e+00 median 5.279680e-02 4.291300e-02 3.800312e-02 0.000000e+00 mean 3.499777e-02 3.710732e-02 -2.554732e-02 -5.379787e-04 SE.mean 3.392155e-02 3.611067e-02 4.623812e-02 3.171197e-02 CI.mean.0.95 6.650788e-02 7.079996e-02 9.065621e-02 6.217570e-02 var 4.052665e+00 4.592620e+00 7.529907e+00 3.541897e+00 std.dev 2.013123e+00 2.143040e+00 2.744068e+00 1.881993e+00 coef.var 5.752148e+01 5.775248e+01 -1.074112e+02 -3.498266e+03 skewness -2.605203e-01 -8.369997e-02 1.547891e-01 -1.523353e-01 skew.2SE -3.157298e+00 -1.014377e+00 1.875920e+00 -1.846181e+00 kurtosis 5.392404e+00 4.077013e+00 7.329406e+00 5.061290e+00 kurt.2SE 3.268507e+01 2.471206e+01 4.442585e+01 3.067808e+01 normtest.W 9.550329e-01 9.583075e-01 9.104004e-01 9.381393e-01 normtest.p 1.196739e-31 1.172506e-30 1.882675e-41 5.179385e-36 XOM GE nbr.val 3.522000e+03 3.522000e+03 nbr.null 2.900000e+01 6.300000e+01 nbr.na 0.000000e+00 0.000000e+00 min -1.502710e+01 -1.368410e+01 max 1.586307e+01 1.798444e+01 range 3.089017e+01 3.166854e+01 sum 9.343915e+01 -5.975640e+01 median 5.437650e-02 0.000000e+00 mean 2.653014e-02 -1.696661e-02 SE.mean 2.745205e-02 3.466683e-02 CI.mean.0.95 5.382353e-02 6.796911e-02 var 2.654232e+00 4.232702e+00 std.dev 1.629181e+00 2.057353e+00 coef.var 6.140870e+01 -1.212589e+02 skewness 4.651513e-02 1.102593e-02 skew.2SE 5.637262e-01 1.336254e-01 kurtosis 1.043194e+01 7.781017e+00 kurt.2SE 6.323129e+01 4.716320e+01 normtest.W 9.160764e-01 9.046828e-01 normtest.p 1.839459e-40 2.126284e-42 "],
["5-graphics-in-r-part-i.html", "Chapter 5 Graphics in R (Part-I) ", " Chapter 5 Graphics in R (Part-I) "],
["5-1-basic-plots-in-r.html", "5.1 Basic Plots in R", " 5.1 Basic Plots in R 5.1.1 Scatter Plot One of the most popular and most frequently used functions to build a new plot in R is the \\(\\mathtt{plot}\\) function. Plot is a high level generic graphic function which depends on the class of the first argument (usually the data object). For example if the first argument is of the class zoo which is a timeseries object the \\(\\mathtt{plot}\\) function will call \\(\\mathtt{plot.zoo}\\) from the R package zoo. This time series plot can be a single timeseries line plot or multiple time series stacked plot. # Generate two random normal vectors x = rnorm(100) y = rnorm(100) # plot x and y using the plot() function plot(x, y) Figure 5.1: Simple Scatter Plot There are various other arguments which can be modified to change the overall presentation of the plot and even the type of plot. args(plot.default) function (x, y = NULL, type = &quot;p&quot;, xlim = NULL, ylim = NULL, log = &quot;&quot;, main = NULL, sub = NULL, xlab = NULL, ylab = NULL, ann = par(&quot;ann&quot;), axes = TRUE, frame.plot = axes, panel.first = NULL, panel.last = NULL, asp = NA, xgap.axis = NA, ygap.axis = NA, ...) NULL The following example uses the argument \\(\\mathtt{main}\\) in the \\(\\mathtt{plot}\\) function to include a title on the plot along with axis tiles using the arguments \\(\\mathtt{xlab}\\) and \\(\\mathtt{ylab}\\). plot(x, y, main = &quot;Figure-2&quot;, xlab = &quot;Normal X&quot;, ylab = &quot;Normal Y&quot;) Figure 5.2: Simple Scatter Plot with Title 5.1.2 Line Plot The following example demonstrates how to create a line plot using Microsoft prices given in the data file \\(\\mathtt{data\\_fin.RData}\\). # change the working directory to the folder containing data_fin.csv or provide # the full path with the filename load(&quot;data/data_fin.RData&quot;) # column names colnames(FinData) [1] &quot;Date&quot; &quot;DJI&quot; &quot;AXP&quot; &quot;MMM&quot; &quot;ATT&quot; &quot;BA&quot; &quot;CAT&quot; &quot;CISCO&quot; &quot;DD&quot; [10] &quot;XOM&quot; &quot;GE&quot; &quot;GS&quot; &quot;HD&quot; &quot;IBM&quot; &quot;INTC&quot; &quot;JNJ&quot; &quot;JPM&quot; &quot;MRK&quot; [19] &quot;MCD&quot; &quot;MSFT&quot; &quot;NKE&quot; # plot a line plot for Dow Jones stock index prices plot(FinData$MSFT, type = &quot;l&quot;, main = &quot;Microsoft Prices&quot;, ylab = &quot;Prices&quot;) Figure 5.3: Line Chart Plotting it as Time Series data Various R packages provide functionality to plot specific data types. For example, \\(\\mathtt{zoo}\\) can be used to plot time series data. library(zoo) # convert data to class zoo FinData.ts = zoo(FinData[, 2:5], order.by = FinData$Date) # plot multiple stacked plot plot(FinData.ts, col = gray.colors(4)) #figure-4 Figure 5.4: Time Series Plot 5.1.3 Bar Plot The function \\(\\mathtt{barplot}\\) creates bar graphs in R. The main data argument in this function is \\(\\mathtt{height}\\) which can be a vector or a matrix of values describing the bars which make up the plot. If \\(\\mathtt{height}\\)is a matrix the bar graph can be a stacked graph or a juxtaposed graph with \\(\\mathtt{besides=TRUE}\\) load(&quot;data/GDP_Yearly.RData&quot;) par1 = par() par(ask = F) barplot(height = GDP$Australia, names.arg = GDP$Year, ylab = &quot;GDP Per Capita&quot;) #figure-5 Figure 5.5: Bar Graph with argument height as vector It is also possible to create a yearly vertical stacked or yearly horizontal grouped bar plot for the GDP data. The data has to be first converted into a matrix to create stacked or grouped barplots. In this example the argument \\(\\mathtt{legend}\\) specifies the names (Years) to appear in the legend and the argument \\(\\mathtt{args.legend}\\) specifies the position (x=”top”), alignment (horiz=TRUE) and distance from the margin (inset=-0.1). # convert data to matrix data = as.matrix(GDP[, 2:12]) # create row names rownames(data) = GDP$Year # plot a stacked bar plot with legend showing the years barplot(height = data[1:5, ], beside = FALSE, col = rainbow(5), legend = rownames(data[1:5, ]), args.legend = list(x = &quot;top&quot;, horiz = TRUE, inset = -0.1), cex.names = 0.6) Figure 5.6: Vertical Stacked Barplot par(par1) 5.1.4 Pie Chart R provides the function \\(\\mathtt{pie}\\) to create pie graphs. \\(\\mathtt{labels}\\) in 5.7 pie(x = data[1, ], labels = colnames(data)) Figure 5.7: Pie Chart 5.1.5 Scatter Plot The basic \\(\\mathtt{plot}\\) function plots a scatter plot for bivariate or univariate data. It is also possible to create a scatterplot for multivariate data using the \\(\\mathtt{pairs}\\) function. pairs(data[, 1:5]) Figure 5.8: Scatterplot A subset can also be selected using formula method, for example the following R code will generate a scatterplot with only Australia, UK and USA. pairs(~Australia + UK + USA, data = data) Figure 5.9: Scatterplot (subset) "],
["5-2-r-graphical-parameters.html", "5.2 R Graphical Parameters", " 5.2 R Graphical Parameters The \\(\\mathtt{par}\\) function facilitates access and modification of a large list of parameters such as color, margin, number of rows and columns on a graphic device etc (see \\(\\mathtt{help(par)}\\) for a list of such parameters). R provides various margin parameters to tweak inner and outer margins of a graphical device. Figure 5.10: Graph Margins A modification to par always changes the global values of graphic parameters and hence its is a good practice to first store the default parameters in a separate object (variable) which can be later used to restore default graphic parameters. These margins can be altered using or parameters with the first setting the margins in inches and the second in unit of text lines. Setting one of these will adjust the other accordingly. The following example (output not shown here) changes the margins to \\(\\mathtt{c(5,4,7,2)}\\) from the default of \\(\\mathtt{c(5,4,4,2)+0.1}\\) to accommodate a title on top of the figure. # first save the default parameters par.old = par() # change the margins par(mar = c(5, 4, 7, 2)) # plot the bargraph barplot(height = data[1:5, ], beside = FALSE, col = rainbow(5), legend = rownames(data[1:5, ]), args.legend = list(x = &quot;top&quot;, horiz = TRUE, inset = -0.1), cex.names = 0.6) title(&quot;Bar Plot \\n(with custom margins)&quot;) # set parameters to default par(par.old) A multiple plot grid can be created by altering \\(\\mathtt{mfrow}\\) or \\(\\mathtt{mfcol}\\) parameter which specifies the number of rows and columns in a grid. # first save the default parameters par.old = par() # creat a 2X2 grid par(mfrow = c(2, 2)) # scatterplot plot(x, y, xlab = &quot;Normal X&quot;, ylab = &quot;Normal Y&quot;) # time series plot plot(FinData.ts[, 1]) # bar plot barplot(height = GDP$Australia, names.arg = GDP$Year, ylab = &quot;GDP Per Capita (Australia)&quot;) # pie chart pie(x = data[1:11, 1], labels = rownames(data[1:11, ])) # set parameters to default par(par.old) Figure 5.11: Multiple Plots in a Grid "],
["5-3-introduction-to-ggplot2.html", "5.3 Introduction to ggplot2", " 5.3 Introduction to ggplot2 ggplot2 (Wickham 2009) is an R package which provides a large variety of plotting functionality to enable better and highly customisable graphs. These functions in ggplot2 are based on the grammar of graphics (Wickham 2010) which is a more formal and structured way to plotting, for a list of various possible graphs, customisation settings and procedures see https://ggplot2.tidyverse.org/ 5.3.1 \\(\\mathtt{qplot}\\) \\(\\mathtt{qplot}\\) stands for quick plot and it makes is easy to produce plots which may often require several lines of codes using base R graphics system. \\(\\mathtt{qplot}\\) is particularly useful for beginners as they are just getting used to the \\(\\mathtt{plot}\\) function from the base package also the data arguments in \\(\\mathtt{qplot}\\) are same as in the \\(\\mathtt{plot}\\) function (see \\(\\mathtt{help(qplot)}\\) for other arguments to the function). x = rnorm(100) y = rnorm(100) # load the library library(ggplot2) # simple scatterplot using qplot qplot(x, y) Figure 5.12: Scatterplot using qplot The argument geom, which stands for geometric objects drawn to represent data has to be changed to “line” create this line plot. Similarly there is an option to plot histograms using the argument geom=“histogram” load(&quot;data/data_fin.RData&quot;) # line plot using qplot qplot(x = FinData$Date, y = FinData$DJI, geom = &quot;line&quot;, xlab = &quot;Dates&quot;, ylab = &quot;Prices&quot;, main = &quot;DJIA Price Timeseries&quot;) Figure 5.13: Line Plot with lables using qplot 5.3.2 Layered graphics using \\(\\mathtt{ggplot}\\) The \\(\\mathtt{qplot}\\) function is just sufficient for creating various plots with better presentation compared to base R plots but the true capabilities of ggplot2 are realised by the function \\(\\mathtt{ggplot}\\). It is important to note that \\(\\mathtt{ggplot}\\) function requires the data in “long” format and hence it is required to first transform the dataset to “long” from “wide” format as in ggplot2, groups are identified by rows, not by columns. # Read &#39;long&#39; format data load(&quot;data/GDP_l.RData&quot;) # data snapshot head(GDP_l) Year Country GDP 1 1990 Australia 18247.39 2 1991 Australia 18837.19 3 1992 Australia 18599.00 4 1993 Australia 17658.08 5 1994 Australia 18080.70 6 1995 Australia 20375.30 # creating the aesthetics using ggplot p1 = ggplot(GDP_l, aes(Country, GDP, fill = Year)) A plot can be created by adding another layer to p1 # figure p1 + geom_bar(stat = &quot;identity&quot;) Figure 5.14: Bar Chart Using ggplot function To draw a line chart using \\(\\mathtt{ggplot}\\), \\(\\mathtt{geom\\_line()}\\) # change the aesthetics to show time on X-axis and GDP values on Y-axis the # colour line fill be according to the country p2 = ggplot(GDP_l, aes(Year, GDP, colour = Country, group = Country)) p2 + geom_line() Figure 5.15: Line Chart Using ggplot These lines can also be drawn in separate panels using faceting. Faceting creates a subplot for each group side by side. Faceting can be used to either to split the data into vertical groups using \\(\\mathtt{facet\\_grid}\\) or horizontal groups using \\(\\mathtt{facet\\_wrap}\\). Figure plots GDP for each country in a separate subplot using grid faceting. # change the aesthetics to show time on X-axis and GDP values on Y-axis the # colour line fill be according to the country p2 = ggplot(GDP_l, aes(Year, GDP, colour = Country, group = Country)) p2 + geom_line() + facet_grid(Country ~ .) Figure 5.16: Faceting in ggplot (Line Chart) 5.3.3 Arranging plots using gridExtra There are a few pacakges which allow to arrange ggplots in a grid or a speacific order. gridExtra is one of them and is quite useful in arranging the plots. Look at the Vignette for egg package for more options. https://cran.r-project.org/web/packages/egg/vignettes/Ecosystem.html Let’s create three ggplots p1.1 = ggplot(GDP_l, aes(x = Year, y = GDP)) p2.1 = p1.1 + geom_bar(aes(fill = Country), stat = &quot;identity&quot;, position = &quot;dodge&quot;) Stacked bar chart (previous example) p1.2 = ggplot(GDP_l[GDP_l$Country %in% c(&quot;Australia&quot;, &quot;UK&quot;, &quot;USA&quot;), ], aes(Year, GDP)) p2.2 = p1.2 + geom_col(aes(fill = Country)) + labs(title = &quot;GDP for Aus, US and UK&quot;) #using labs to modify title p2.2 Figure 5.17: Bar Chart with Selected Data Stock data p1.3 = ggplot(FinData, aes(x = Date, y = DJI)) p2.3 = p1.3 + geom_path(colour = &quot;darkblue&quot;) + geom_smooth(colour = &quot;black&quot;) + theme_linedraw() #changing theme p2.3 Figure 5.18: Stock Series Plot with Smooth Curve Now use gridExtra to put these together library(gridExtra) fig1 = grid.arrange(p2.1, p2.2, p2.3, nrow = 3, heights = c(20, 12, 12), top = &quot;Combined plots in three rows&quot;) Figure 5.19: Combined plots The plots can be saved using the \\(\\mathtt{ggsave}\\) function ggsave(filename = &quot;combined_plot.pdf&quot;, plot = fig1) References "],
["6-graphics-in-r-part-ii.html", "Chapter 6 Graphics in R (Part-II) ", " Chapter 6 Graphics in R (Part-II) "],
["6-1-interactive-plots-using-plotly.html", "6.1 Interactive Plots using Plotly", " 6.1 Interactive Plots using Plotly Here we will use the COVID-19 data provided by John Hopkins University library(ggplot2) library(maps) library(ggthemes) library(plotly) library(scales) library(dplyr) library(tidyr) # download data d1 = read.csv(&quot;https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv&quot;, check.names = FALSE) # head(d1) Data is in wide format let’s convert in long format for visualisation # rename Provice/State and Country columns colnames(d1)[1:2] = c(&quot;State&quot;, &quot;Country&quot;) d1.2 = pivot_longer(d1, cols = -c(State, Country, Lat, Long), names_to = &quot;Date&quot;, values_to = &quot;Cases&quot;) # convert dates d1.2$Date = as.Date(d1.2$Date, format = &quot;%m/%e/%y&quot;) Aggregate cases by day (dropping the state) d2 = aggregate(d1.2$Cases, by = list(Lat = d1.2$Lat, Long = d1.2$Long, Country = d1.2$Country, Date = d1.2$Date), FUN = sum) colnames(d2)[5] = &quot;Cases&quot; # reorder d2 = d2[, c(4, 1, 2, 3, 5)] Let’s find top 10 by case numbers Using aggregate to find sum by country to find top 10 top1 = aggregate(d2$Cases, by = list(Date = d2$Date, Country = d2$Country), FUN = sum) # select the last date to get overall total top10 = top1[top1$Date == &quot;2020-07-25&quot;, ] # select top 10 top10 = top10[order(-top10$x), ][1:10, ] # let&#39;s include Aus top10_country = c(top10$Country, &quot;Australia&quot;) Use ggplot to create a line chart 6.1 colnames(top1)[3] = &quot;Cases&quot; data_p = top1[top1$Country %in% c(as.character(top10_country)), ] p1 = ggplot(data = data_p, aes(Date, log(Cases), color = Country, group = Country)) + geom_line(stat = &quot;identity&quot;, size = 1) + scale_x_date(labels = date_format(&quot;%d/%m&quot;), breaks = &quot;7 days&quot;) + theme_wsj() p1 Figure 6.1: Line Chart with Custom Theme Create custom color vector and a line chart with basic theme to convert to plotly 6.2 myCol2 = c(&quot;slateblue1&quot;, &quot;purple3&quot;, &quot;turquoise2&quot;, &quot;skyblue&quot;, &quot;steelblue&quot;, &quot;blue2&quot;, &quot;navyblue&quot;, &quot;orange&quot;, &quot;tomato&quot;, &quot;coral2&quot;, &quot;palevioletred&quot;, &quot;violetred&quot;, &quot;red2&quot;, &quot;springgreen2&quot;, &quot;yellowgreen&quot;, &quot;palegreen4&quot;, &quot;wheat2&quot;, &quot;tan&quot;, &quot;tan2&quot;, &quot;tan3&quot;, &quot;brown&quot;, &quot;grey70&quot;, &quot;grey50&quot;, &quot;grey30&quot;) p2 = ggplot(data_p, aes(Date, Cases, group = Country, color = Country)) + geom_line(size = 1.5) + geom_point(size = 1.5) + scale_colour_manual(values = myCol2, &quot;Countries&quot;) + geom_text(data = data_p[data_p$Date == max(data_p$Date), ], aes(x = as.Date(max(data_p$Date) + 4), label = Country), hjust = -0.01, nudge_y = 0.01, show.legend = FALSE) + expand_limits(x = as.Date(c(min(data_p$Date), max(data_p$Date) + 5))) + scale_x_date(breaks = seq(as.Date(min(data_p$Date)), as.Date(max(data_p$Date) + 5), by = &quot;7 days&quot;), date_labels = &quot;%m/%d&quot;) + scale_y_continuous(labels = comma) + theme_classic() + theme(axis.title = element_text(size = 15, face = &quot;bold&quot;)) p2 Figure 6.2: Line Chart Convert to plotly for interactive graphics 6.3 fig_p2 = ggplotly(p2) fig_p2 Figure 6.3: Interactive Line Chart "],
["6-2-animation-using-gganimate.html", "6.2 Animation using gganimate", " 6.2 Animation using gganimate We can also use the gganimate package to convert the image into a gif. Its also possible to create animations with plotly 6.4 library(gganimate) p1.anim = p1 + transition_reveal(Date) anim_p1 = animate(p1.anim, fps = 2, start_pause = 2, end_pause = 5, rewind = FALSE, width = 800, height = 1000) anim_save(filename = &quot;covid_cases_log_2020jul.gif&quot;, animation = anim_p1) Figure 6.4: Animated Graph "],
["6-3-plot-maps.html", "6.3 Plot Maps", " 6.3 Plot Maps We can also plot the data on a map 6.5 world = map_data(&quot;world&quot;) w1 = ggplot() + geom_polygon(data = world, aes(color = region, x = long, y = lat, group = group), fill = &quot;white&quot;) + theme_map() + theme(legend.position = &quot;none&quot;) + scale_fill_brewer(palette = &quot;Blues&quot;) map1 = w1 + geom_point(aes(x = Long, y = Lat, size = Cases, colour = Country), data = d2) + labs(title = &quot;COVID-19 Cases&quot;) # static version map1 Figure 6.5: Map Interactive version using plotly 6.6 # interactive version ggplotly(map1) Figure 6.6: Interactive Map "],
["7-final-words.html", "Chapter 7 Final Words", " Chapter 7 Final Words We have finished a quick intro to R "],
["references.html", "References", " References "]
]
